# Домашнее задание к занятию "`«PostgreSQL»`" - `Бызгаев Александр`

---

### Задание 1

Используя Docker, поднимите инстанс PostgreSQL (версию 13).   
Данные БД сохраните в volume.  
Подключитесь к БД PostgreSQL, используя psql.  
Воспользуйтесь командой \? для вывода подсказки по имеющимся в psql управляющим командам.  
Найдите и приведите управляющие команды для:
- вывода списка БД,  
- подключения к БД,  
- вывода списка таблиц,  
- вывода описания содержимого таблиц,  
- выхода из psql.  

### Выполнения задания 1

1 **Создание Docker Volume**    
```bash
docker volume create postgres_data
```
2 **Запуск контейнера PostgreSQL:**      
```bash
docker run --name my_postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 -v postgres_data:/var/lib/postgresql/data postgres:13
```
3 **Подключение к БД PostgreSQL используя psql:**       
  - Сначала войдите в контейнер:  
```bash
docker exec -it my_postgres bash  
```
Затем подключитесь к PostgreSQL через psql, используя имя пользователя (по умолчанию postgres):  
```bash
psql -U postgres
```
4 **Вывод подсказки по управляющим командам в psql:**  
  - В psql выполните команду:
```bash
\?
```
5 **Найдите и приведите управляющие команды для:** 
  - вывода списка БД: \l  
  - подключения к БД: \connect db_name  
  - вывода списка таблиц: \dt  
  - удалить базу: drop database db_name;  
  - вывода описания(подробное) содержимого таблиц: \d+ table_name  
  - выхода из psql: \q либо exit  
  - справка: \?  

----

### Задание 2

Используя psql, создайте БД test_database.  
Изучите бэкап БД.  
Восстановите бэкап БД в test_database.  
Перейдите в управляющую консоль psql внутри контейнера.  
Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.  
Используя таблицу pg_stats, найдите столбец таблицы orders с наибольшим средним значением размера элементов в байтах.  
Приведите в ответе команду, которую вы использовали для вычисления, и полученный результат.  

----

### Выполнения задания 2  

Команда для вычисления:
```bash
SELECT attname, avg_width FROM pg_stats WHERE tablename='orders' ORDER BY avg_width DESC LIMIT 1;
```

![image.jpg](https://github.com/Byzgaev-I/PostgreSQL/blob/main/2.png)


----

### Задание 3

Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров и поиск по ней занимает долгое время.   
Вам как успешному выпускнику курсов DevOps в Нетологии предложили провести разбиение таблицы на 2: шардировать на orders_1 - price>499 и orders_2 - price<=499.  
Предложите SQL-транзакцию для проведения этой операции.  
Можно ли было изначально исключить ручное разбиение при проектировании таблицы orders?

----

### Выполнения задания 3

Для выполнения задачи разбиения (шардирования) таблицы orders на две части по критерию price, можно использовать следующую последовательность SQL-команд.  
Операции будут выполнены в транзакции, чтобы обеспечить целостность данных:  

**Шаг 1: Создание новых таблиц**

```bash
BEGIN;

CREATE TABLE orders_1 LIKE orders;
CREATE TABLE orders_2 LIKE orders;

COMMIT;

```
**Шаг 2: Разделение данных**

```bash
BEGIN;

INSERT INTO orders_1 SELECT * FROM orders WHERE price > 499;
INSERT INTO orders_2 SELECT * FROM orders WHERE price <= 499;

COMMIT;
```
**Шаг 3:  Удаление данных из оригинальной таблицы**
Этот шаг необходимо выполнить только после того, как мыубедились, что данные корректно скопированы в новые таблицы.   
Удаление данных из исходной таблицы orders можно выполнить следующим образом: 

```bash
BEGIN;

DELETE FROM orders;

COMMIT;
```

**Шаг 4:  Перенаправление приложений**

На этом этапе нам нужно будет обновить приложения или промежуточное программное обеспечение, чтобы оно корректно обрабатывало данные в новых таблицах orders_1 и orders_2.

Также наковырял в инете такое **альтернативное решение:  Партиционирование**  
При проектировании таблицы orders можно было изначально предусмотреть партиционирование данных на уровне базы данных.  
Это позволило бы избежать ручного разбиения таблицы в будущем. MySQL поддерживает партиционирование таблиц по различным критериям, включая диапазоны значений (RANGE), значения ключей (HASH), и другие.  
Пример создания таблицы orders с партиционированием по диапазону цены:  

```bash
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT,
    product_id INT,
    quantity INT,
    price DECIMAL(10,2),
    order_date DATETIME,
    PRIMARY KEY (order_id)
)
PARTITION BY RANGE (price) (
    PARTITION p0 VALUES LESS THAN (500),
    PARTITION p1 VALUES LESS THAN MAXVALUE
);

```
Эта структура позволяет автоматически разделять данные по разным партициям в зависимости от цены, что упрощает управление данными и может улучшить производительность запросов, особенно на больших объемах данных.

----

### Задание 4

Используя утилиту pg_dump, создайте бекап БД test_database.  
Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца title для таблиц test_database?  

----

### Выполнения задания 4

 **Используя утилиту pg_dump создайте бекап БД test_database:**

```bash
pg_dump -U user -F c test_database > test_database.sql
```

**Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца title для таблиц test_database?**

Создал бэкап в plain text формате:
```bash
pg_dump -U username -W -F p -d test_database -f test_database_backup.sql
```
**Редактирование SQL файла:**

- Открыл файл test_database_backup.sql в текстовом редакторе.      
- Добавил уникальность для столбца title.      
  Это будет часть SQL команды CREATE TABLE.    
- Добавил ограничение UNIQUE на столбец title:    
```bash
CREATE TABLE your_table_name (
    ...
    title VARCHAR(255) UNIQUE,
    ...
);
```
Добавил уникальный индекс бы, если уже есть индекс для этого столбца. (нарыл в инете)
```bash
CREATE UNIQUE INDEX idx_unique_title ON your_table_name (title);  
```

 **Добавление уникальности после восстановления**  
 Если база данных уже восстановлена, вы можете добавить уникальное ограничение, используя команду ALTER TABLE. Для этого:    
 
 ```bash
ALTER TABLE название_таблицы ADD CONSTRAINT название_ограничения UNIQUE (title);
```
Добавление уникальности значения столбца title поможет гарантировать, что в таблице не будет двух строк с одинаковыми значениями в этом столбце, что может быть критически важно для целостности данных.


















